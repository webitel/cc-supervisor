{
  "version": 3,
  "sources": ["../../node_modules/qs-esm/lib/stringify.js", "../../node_modules/qs-esm/lib/utils.js", "../../node_modules/qs-esm/lib/formats.js", "../../node_modules/qs-esm/lib/index.js", "../../node_modules/qs-esm/lib/parse.js"],
  "sourcesContent": ["'use strict'\n\nimport * as utils from './utils.js'\nimport * as formats from './formats.js'\n\nconst has = Object.prototype.hasOwnProperty\n\nconst arrayPrefixGenerators = {\n  brackets: function brackets(prefix) {\n    return prefix + '[]'\n  },\n  comma: 'comma',\n  indices: function indices(prefix, key) {\n    return prefix + '[' + key + ']'\n  },\n  repeat: function repeat(prefix) {\n    return prefix\n  },\n}\n\nconst isArray = Array.isArray\nconst push = Array.prototype.push\nconst pushToArray = function (arr, valueOrArray) {\n  push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray])\n}\n\nconst toISO = Date.prototype.toISOString\n\nconst defaultFormat = formats['default']\nconst defaults = {\n  addQueryPrefix: false,\n  allowDots: false,\n  allowEmptyArrays: false,\n  arrayFormat: 'indices',\n  charset: 'utf-8',\n  charsetSentinel: false,\n  delimiter: '&',\n  encode: true,\n  encodeDotInKeys: false,\n  encoder: utils.encode,\n  encodeValuesOnly: false,\n  format: defaultFormat,\n  formatter: formats.formatters[defaultFormat],\n  // deprecated\n  indices: false,\n  serializeDate: function serializeDate(date) {\n    return toISO.call(date)\n  },\n  skipNulls: false,\n  strictNullHandling: false,\n}\n\nconst isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n  return (\n    typeof v === 'string' ||\n    typeof v === 'number' ||\n    typeof v === 'boolean' ||\n    typeof v === 'symbol' ||\n    typeof v === 'bigint'\n  )\n}\n\nconst sentinel = {}\n\nconst _stringify = function stringify(\n  object,\n  prefix,\n  generateArrayPrefix,\n  commaRoundTrip,\n  allowEmptyArrays,\n  strictNullHandling,\n  skipNulls,\n  encodeDotInKeys,\n  encoder,\n  filter,\n  sort,\n  allowDots,\n  serializeDate,\n  format,\n  formatter,\n  encodeValuesOnly,\n  charset,\n  sideChannel,\n) {\n  let obj = object\n\n  let tmpSc = sideChannel\n  let step = 0\n  let findFlag = false\n  while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n    // Where object last appeared in the ref tree\n    const pos = tmpSc.get(object)\n    step += 1\n    if (typeof pos !== 'undefined') {\n      if (pos === step) {\n        throw new RangeError('Cyclic object value')\n      } else {\n        findFlag = true // Break while\n      }\n    }\n    if (typeof tmpSc.get(sentinel) === 'undefined') {\n      step = 0\n    }\n  }\n\n  if (typeof filter === 'function') {\n    obj = filter(prefix, obj)\n  } else if (obj instanceof Date) {\n    obj = serializeDate(obj)\n  } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n    obj = utils.maybeMap(obj, function (value) {\n      if (value instanceof Date) {\n        return serializeDate(value)\n      }\n      return value\n    })\n  }\n\n  if (obj === null) {\n    if (strictNullHandling) {\n      return encoder && !encodeValuesOnly\n        ? encoder(prefix, defaults.encoder, charset, 'key', format)\n        : prefix\n    }\n\n    obj = ''\n  }\n\n  if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n    if (encoder) {\n      const keyValue = encodeValuesOnly\n        ? prefix\n        : encoder(prefix, defaults.encoder, charset, 'key', format)\n      return [\n        formatter(keyValue) +\n          '=' +\n          formatter(encoder(obj, defaults.encoder, charset, 'value', format)),\n      ]\n    }\n    return [formatter(prefix) + '=' + formatter(String(obj))]\n  }\n\n  const values = []\n\n  if (typeof obj === 'undefined') {\n    return values\n  }\n\n  let objKeys\n  if (generateArrayPrefix === 'comma' && isArray(obj)) {\n    // we need to join elements in\n    if (encodeValuesOnly && encoder) {\n      obj = utils.maybeMap(obj, encoder)\n    }\n    objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }]\n  } else if (isArray(filter)) {\n    objKeys = filter\n  } else {\n    const keys = Object.keys(obj)\n    objKeys = sort ? keys.sort(sort) : keys\n  }\n\n  const encodedPrefix = encodeDotInKeys ? prefix.replace(/\\./g, '%2E') : prefix\n\n  const adjustedPrefix =\n    commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix\n\n  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {\n    return adjustedPrefix + '[]'\n  }\n\n  for (let j = 0; j < objKeys.length; ++j) {\n    const key = objKeys[j]\n    const value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key]\n\n    if (skipNulls && value === null) {\n      continue\n    }\n\n    const encodedKey = allowDots && encodeDotInKeys ? key.replace(/\\./g, '%2E') : key\n    const keyPrefix = isArray(obj)\n      ? typeof generateArrayPrefix === 'function'\n        ? generateArrayPrefix(adjustedPrefix, encodedKey)\n        : adjustedPrefix\n      : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']')\n\n    sideChannel.set(object, step)\n    const valueSideChannel = new WeakMap()\n    valueSideChannel.set(sentinel, sideChannel)\n    pushToArray(\n      values,\n      _stringify(\n        value,\n        keyPrefix,\n        generateArrayPrefix,\n        commaRoundTrip,\n        allowEmptyArrays,\n        strictNullHandling,\n        skipNulls,\n        encodeDotInKeys,\n        generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,\n        filter,\n        sort,\n        allowDots,\n        serializeDate,\n        format,\n        formatter,\n        encodeValuesOnly,\n        charset,\n        valueSideChannel,\n      ),\n    )\n  }\n\n  return values\n}\n\nconst normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n  if (!opts) {\n    return defaults\n  }\n\n  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided')\n  }\n\n  if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n    throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided')\n  }\n\n  if (\n    opts.encoder !== null &&\n    typeof opts.encoder !== 'undefined' &&\n    typeof opts.encoder !== 'function'\n  ) {\n    throw new TypeError('Encoder has to be a function.')\n  }\n\n  const charset = opts.charset || defaults.charset\n  if (\n    typeof opts.charset !== 'undefined' &&\n    opts.charset !== 'utf-8' &&\n    opts.charset !== 'iso-8859-1'\n  ) {\n    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined')\n  }\n\n  let format = formats['default']\n  if (typeof opts.format !== 'undefined') {\n    if (!has.call(formats.formatters, opts.format)) {\n      throw new TypeError('Unknown format option provided.')\n    }\n    format = opts.format\n  }\n  const formatter = formats.formatters[format]\n\n  let filter = defaults.filter\n  if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n    filter = opts.filter\n  }\n\n  let arrayFormat\n  if (opts.arrayFormat in arrayPrefixGenerators) {\n    arrayFormat = opts.arrayFormat\n  } else if ('indices' in opts) {\n    arrayFormat = opts.indices ? 'indices' : 'repeat'\n  } else {\n    arrayFormat = defaults.arrayFormat\n  }\n\n  if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n    throw new TypeError('`commaRoundTrip` must be a boolean, or absent')\n  }\n\n  const allowDots =\n    typeof opts.allowDots === 'undefined'\n      ? opts.encodeDotInKeys === true\n        ? true\n        : defaults.allowDots\n      : !!opts.allowDots\n\n  return {\n    addQueryPrefix:\n      typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n    allowDots: allowDots,\n    allowEmptyArrays:\n      typeof opts.allowEmptyArrays === 'boolean'\n        ? !!opts.allowEmptyArrays\n        : defaults.allowEmptyArrays,\n    arrayFormat: arrayFormat,\n    charset: charset,\n    charsetSentinel:\n      typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n    commaRoundTrip: opts.commaRoundTrip,\n    delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n    encodeDotInKeys:\n      typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n    encodeValuesOnly:\n      typeof opts.encodeValuesOnly === 'boolean'\n        ? opts.encodeValuesOnly\n        : defaults.encodeValuesOnly,\n    filter: filter,\n    format: format,\n    formatter: formatter,\n    serializeDate:\n      typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n    sort: typeof opts.sort === 'function' ? opts.sort : null,\n    strictNullHandling:\n      typeof opts.strictNullHandling === 'boolean'\n        ? opts.strictNullHandling\n        : defaults.strictNullHandling,\n  }\n}\n\nexport function stringify(object, opts) {\n  let obj = object\n  const options = normalizeStringifyOptions(opts)\n\n  let objKeys\n  let filter\n\n  if (typeof options.filter === 'function') {\n    filter = options.filter\n    obj = filter('', obj)\n  } else if (isArray(options.filter)) {\n    filter = options.filter\n    objKeys = filter\n  }\n\n  const keys = []\n\n  if (typeof obj !== 'object' || obj === null) {\n    return ''\n  }\n\n  const generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat]\n  const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip\n\n  if (!objKeys) {\n    objKeys = Object.keys(obj)\n  }\n\n  if (options.sort) {\n    objKeys.sort(options.sort)\n  }\n\n  const sideChannel = new WeakMap()\n  for (let i = 0; i < objKeys.length; ++i) {\n    const key = objKeys[i]\n\n    if (options.skipNulls && obj[key] === null) {\n      continue\n    }\n    pushToArray(\n      keys,\n      _stringify(\n        obj[key],\n        key,\n        generateArrayPrefix,\n        commaRoundTrip,\n        options.allowEmptyArrays,\n        options.strictNullHandling,\n        options.skipNulls,\n        options.encodeDotInKeys,\n        options.encode ? options.encoder : null,\n        options.filter,\n        options.sort,\n        options.allowDots,\n        options.serializeDate,\n        options.format,\n        options.formatter,\n        options.encodeValuesOnly,\n        options.charset,\n        sideChannel,\n      ),\n    )\n  }\n\n  const joined = keys.join(options.delimiter)\n  let prefix = options.addQueryPrefix === true ? '?' : ''\n\n  if (options.charsetSentinel) {\n    if (options.charset === 'iso-8859-1') {\n      // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n      prefix += 'utf8=%26%2310003%3B&'\n    } else {\n      // encodeURIComponent('✓')\n      prefix += 'utf8=%E2%9C%93&'\n    }\n  }\n\n  return joined.length > 0 ? prefix + joined : ''\n}\n", "'use strict'\n\nimport * as formats from './formats.js'\n\nconst has = Object.prototype.hasOwnProperty\nconst isArray = Array.isArray\n\nconst hexTable = (function () {\n  const array = []\n  for (let i = 0; i < 256; ++i) {\n    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase())\n  }\n\n  return array\n})()\n\nconst compactQueue = function compactQueue(queue) {\n  while (queue.length > 1) {\n    const item = queue.pop()\n    const obj = item.obj[item.prop]\n\n    if (isArray(obj)) {\n      const compacted = []\n\n      for (let j = 0; j < obj.length; ++j) {\n        if (typeof obj[j] !== 'undefined') {\n          compacted.push(obj[j])\n        }\n      }\n\n      item.obj[item.prop] = compacted\n    }\n  }\n}\n\nexport const arrayToObject = function arrayToObject(source, options) {\n  const obj = options && options.plainObjects ? Object.create(null) : {}\n  for (let i = 0; i < source.length; ++i) {\n    if (typeof source[i] !== 'undefined') {\n      obj[i] = source[i]\n    }\n  }\n\n  return obj\n}\n\nexport const merge = function merge(target, source, options) {\n  /* eslint no-param-reassign: 0 */\n  if (!source) {\n    return target\n  }\n\n  if (typeof source !== 'object') {\n    if (isArray(target)) {\n      target.push(source)\n    } else if (target && typeof target === 'object') {\n      if (\n        (options && (options.plainObjects || options.allowPrototypes)) ||\n        !has.call(Object.prototype, source)\n      ) {\n        target[source] = true\n      }\n    } else {\n      return [target, source]\n    }\n\n    return target\n  }\n\n  if (!target || typeof target !== 'object') {\n    return [target].concat(source)\n  }\n\n  let mergeTarget = target\n  if (isArray(target) && !isArray(source)) {\n    mergeTarget = arrayToObject(target, options)\n  }\n\n  if (isArray(target) && isArray(source)) {\n    source.forEach(function (item, i) {\n      if (has.call(target, i)) {\n        const targetItem = target[i]\n        if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n          target[i] = merge(targetItem, item, options)\n        } else {\n          target.push(item)\n        }\n      } else {\n        target[i] = item\n      }\n    })\n    return target\n  }\n\n  return Object.keys(source).reduce(function (acc, key) {\n    const value = source[key]\n\n    if (has.call(acc, key)) {\n      acc[key] = merge(acc[key], value, options)\n    } else {\n      acc[key] = value\n    }\n    return acc\n  }, mergeTarget)\n}\n\nexport const assign = function assignSingleSource(target, source) {\n  return Object.keys(source).reduce(function (acc, key) {\n    acc[key] = source[key]\n    return acc\n  }, target)\n}\n\nexport const decode = function (str, decoder, charset) {\n  const strWithoutPlus = str.replace(/\\+/g, ' ')\n  if (charset === 'iso-8859-1') {\n    // unescape never throws, no try...catch needed:\n    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape)\n  }\n  // utf-8\n  try {\n    return decodeURIComponent(strWithoutPlus)\n  } catch (e) {\n    return strWithoutPlus\n  }\n}\n\nconst limit = 1024\n\nexport const encode = function encode(str, defaultEncoder, charset, kind, format) {\n  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n  // It has been adapted here for stricter adherence to RFC 3986\n  if (str.length === 0) {\n    return str\n  }\n\n  let string = str\n  if (typeof str === 'symbol') {\n    string = Symbol.prototype.toString.call(str)\n  } else if (typeof str !== 'string') {\n    string = String(str)\n  }\n\n  if (charset === 'iso-8859-1') {\n    return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n      return '%26%23' + parseInt($0.slice(2), 16) + '%3B'\n    })\n  }\n\n  let out = ''\n  for (let j = 0; j < string.length; j += limit) {\n    const segment = string.length >= limit ? string.slice(j, j + limit) : string\n    const arr = []\n\n    for (let i = 0; i < segment.length; ++i) {\n      let c = segment.charCodeAt(i)\n      if (\n        c === 0x2d || // -\n        c === 0x2e || // .\n        c === 0x5f || // _\n        c === 0x7e || // ~\n        (c >= 0x30 && c <= 0x39) || // 0-9\n        (c >= 0x41 && c <= 0x5a) || // a-z\n        (c >= 0x61 && c <= 0x7a) || // A-Z\n        (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n      ) {\n        arr[arr.length] = segment.charAt(i)\n        continue\n      }\n\n      if (c < 0x80) {\n        arr[arr.length] = hexTable[c]\n        continue\n      }\n\n      if (c < 0x800) {\n        arr[arr.length] = hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)]\n        continue\n      }\n\n      if (c < 0xd800 || c >= 0xe000) {\n        arr[arr.length] =\n          hexTable[0xe0 | (c >> 12)] +\n          hexTable[0x80 | ((c >> 6) & 0x3f)] +\n          hexTable[0x80 | (c & 0x3f)]\n        continue\n      }\n\n      i += 1\n      c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff))\n\n      arr[arr.length] =\n        hexTable[0xf0 | (c >> 18)] +\n        hexTable[0x80 | ((c >> 12) & 0x3f)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)]\n    }\n\n    out += arr.join('')\n  }\n\n  return out\n}\n\nexport const compact = function compact(value) {\n  const queue = [{ obj: { o: value }, prop: 'o' }]\n  const refs = []\n\n  for (let i = 0; i < queue.length; ++i) {\n    const item = queue[i]\n    const obj = item.obj[item.prop]\n\n    const keys = Object.keys(obj)\n    for (let j = 0; j < keys.length; ++j) {\n      const key = keys[j]\n      const val = obj[key]\n      if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n        queue.push({ obj: obj, prop: key })\n        refs.push(val)\n      }\n    }\n  }\n\n  compactQueue(queue)\n\n  return value\n}\n\nexport const isRegExp = function isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]'\n}\n\nexport const isBuffer = function isBuffer(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false\n  }\n\n  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj))\n}\n\nexport const combine = function combine(a, b) {\n  return [].concat(a, b)\n}\n\nexport const maybeMap = function maybeMap(val, fn) {\n  if (isArray(val)) {\n    const mapped = []\n    for (let i = 0; i < val.length; i += 1) {\n      mapped.push(fn(val[i]))\n    }\n    return mapped\n  }\n  return fn(val)\n}\n", "'use strict'\n\nconst replace = String.prototype.replace\nconst percentTwenties = /%20/g\n\nconst Format = {\n  RFC1738: 'RFC1738',\n  RFC3986: 'RFC3986',\n}\n\nexport const formatters = {\n  RFC1738: function (value) {\n    return replace.call(value, percentTwenties, '+')\n  },\n  RFC3986: function (value) {\n    return String(value)\n  },\n}\nexport const RFC1738 = Format.RFC1738\nexport const RFC3986 = Format.RFC3986\n\nexport default Format.RFC3986\n", "'use strict'\n\nexport * as formats from './formats.js'\nexport { stringify } from './stringify.js'\nexport { parse } from './parse.js'\n", "'use strict'\n\nimport * as utils from './utils.js'\n\nconst has = Object.prototype.hasOwnProperty\nconst isArray = Array.isArray\n\nconst defaults = {\n  allowDots: false,\n  allowEmptyArrays: false,\n  allowPrototypes: false,\n  allowSparse: false,\n  arrayLimit: 20,\n  charset: 'utf-8',\n  charsetSentinel: false,\n  comma: false,\n  decodeDotInKeys: false,\n  decoder: utils.decode,\n  delimiter: '&',\n  depth: 5,\n  duplicates: 'combine',\n  ignoreQueryPrefix: false,\n  interpretNumericEntities: false,\n  parameterLimit: 1000,\n  parseArrays: true,\n  plainObjects: false,\n  strictNullHandling: false,\n}\n\nconst interpretNumericEntities = function (str) {\n  return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n    return String.fromCharCode(parseInt(numberStr, 10))\n  })\n}\n\nconst parseArrayValue = function (val, options) {\n  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n    return val.split(',')\n  }\n\n  return val\n}\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nconst isoSentinel = 'utf8=%26%2310003%3B' // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nconst charsetSentinel = 'utf8=%E2%9C%93' // encodeURIComponent('✓')\n\nconst parseValues = function parseQueryStringValues(str, options) {\n  const obj = { __proto__: null }\n\n  const cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str\n  const limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit\n  const parts = cleanStr.split(options.delimiter, limit)\n  let skipIndex = -1 // Keep track of where the utf8 sentinel was found\n  let i\n\n  let charset = options.charset\n  if (options.charsetSentinel) {\n    for (i = 0; i < parts.length; ++i) {\n      if (parts[i].indexOf('utf8=') === 0) {\n        if (parts[i] === charsetSentinel) {\n          charset = 'utf-8'\n        } else if (parts[i] === isoSentinel) {\n          charset = 'iso-8859-1'\n        }\n        skipIndex = i\n        i = parts.length // The eslint settings do not allow break;\n      }\n    }\n  }\n\n  for (i = 0; i < parts.length; ++i) {\n    if (i === skipIndex) {\n      continue\n    }\n    const part = parts[i]\n\n    const bracketEqualsPos = part.indexOf(']=')\n    const pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1\n\n    let key, val\n    if (pos === -1) {\n      key = options.decoder(part, defaults.decoder, charset, 'key')\n      val = options.strictNullHandling ? null : ''\n    } else {\n      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key')\n      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {\n        return options.decoder(encodedVal, defaults.decoder, charset, 'value')\n      })\n    }\n\n    if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n      val = interpretNumericEntities(val)\n    }\n\n    if (part.indexOf('[]=') > -1) {\n      val = isArray(val) ? [val] : val\n    }\n\n    const existing = has.call(obj, key)\n    if (existing && options.duplicates === 'combine') {\n      obj[key] = utils.combine(obj[key], val)\n    } else if (!existing || options.duplicates === 'last') {\n      obj[key] = val\n    }\n  }\n\n  return obj\n}\n\nconst parseObject = function (chain, val, options, valuesParsed) {\n  let leaf = valuesParsed ? val : parseArrayValue(val, options)\n\n  for (let i = chain.length - 1; i >= 0; --i) {\n    let obj\n    const root = chain[i]\n\n    if (root === '[]' && options.parseArrays) {\n      obj = options.allowEmptyArrays && leaf === '' ? [] : [].concat(leaf)\n    } else {\n      obj = options.plainObjects ? Object.create(null) : {}\n      const cleanRoot =\n        root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root\n      const decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot\n      const index = parseInt(decodedRoot, 10)\n      if (!options.parseArrays && decodedRoot === '') {\n        obj = { 0: leaf }\n      } else if (\n        !isNaN(index) &&\n        root !== decodedRoot &&\n        String(index) === decodedRoot &&\n        index >= 0 &&\n        options.parseArrays &&\n        index <= options.arrayLimit\n      ) {\n        obj = []\n        obj[index] = leaf\n      } else if (decodedRoot !== '__proto__') {\n        obj[decodedRoot] = leaf\n      }\n    }\n\n    leaf = obj\n  }\n\n  return leaf\n}\n\nconst parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n  if (!givenKey) {\n    return\n  }\n\n  // Transform dot notation to bracket notation\n  const key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey\n\n  // The regex chunks\n\n  const brackets = /(\\[[^[\\]]*])/\n  const child = /(\\[[^[\\]]*])/g\n\n  // Get the parent\n\n  let segment = options.depth > 0 && brackets.exec(key)\n  const parent = segment ? key.slice(0, segment.index) : key\n\n  // Stash the parent if it exists\n\n  const keys = []\n  if (parent) {\n    // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n    if (!options.plainObjects && has.call(Object.prototype, parent)) {\n      if (!options.allowPrototypes) {\n        return\n      }\n    }\n\n    keys.push(parent)\n  }\n\n  // Loop through children appending to the array until we hit depth\n\n  let i = 0\n  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n    i += 1\n    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n      if (!options.allowPrototypes) {\n        return\n      }\n    }\n    keys.push(segment[1])\n  }\n\n  // If there's a remainder, just add whatever is left\n\n  if (segment) {\n    keys.push('[' + key.slice(segment.index) + ']')\n  }\n\n  return parseObject(keys, val, options, valuesParsed)\n}\n\nconst normalizeParseOptions = function normalizeParseOptions(opts) {\n  if (!opts) {\n    return defaults\n  }\n\n  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided')\n  }\n\n  if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {\n    throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided')\n  }\n\n  if (\n    opts.decoder !== null &&\n    typeof opts.decoder !== 'undefined' &&\n    typeof opts.decoder !== 'function'\n  ) {\n    throw new TypeError('Decoder has to be a function.')\n  }\n\n  if (\n    typeof opts.charset !== 'undefined' &&\n    opts.charset !== 'utf-8' &&\n    opts.charset !== 'iso-8859-1'\n  ) {\n    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined')\n  }\n  const charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset\n\n  const duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates\n\n  if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {\n    throw new TypeError('The duplicates option must be either combine, first, or last')\n  }\n\n  const allowDots =\n    typeof opts.allowDots === 'undefined'\n      ? opts.decodeDotInKeys === true\n        ? true\n        : defaults.allowDots\n      : !!opts.allowDots\n\n  return {\n    allowDots: allowDots,\n    allowEmptyArrays:\n      typeof opts.allowEmptyArrays === 'boolean'\n        ? !!opts.allowEmptyArrays\n        : defaults.allowEmptyArrays,\n    allowPrototypes:\n      typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n    allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n    arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n    charset: charset,\n    charsetSentinel:\n      typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n    comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n    decodeDotInKeys:\n      typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,\n    decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n    delimiter:\n      typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter)\n        ? opts.delimiter\n        : defaults.delimiter,\n    // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n    depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,\n    duplicates: duplicates,\n    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n    interpretNumericEntities:\n      typeof opts.interpretNumericEntities === 'boolean'\n        ? opts.interpretNumericEntities\n        : defaults.interpretNumericEntities,\n    parameterLimit:\n      typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n    parseArrays: opts.parseArrays !== false,\n    plainObjects:\n      typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n    strictNullHandling:\n      typeof opts.strictNullHandling === 'boolean'\n        ? opts.strictNullHandling\n        : defaults.strictNullHandling,\n  }\n}\n\nexport function parse(str, opts) {\n  const options = normalizeParseOptions(opts)\n\n  if (str === '' || str === null || typeof str === 'undefined') {\n    return options.plainObjects ? Object.create(null) : {}\n  }\n\n  const tempObj = typeof str === 'string' ? parseValues(str, options) : str\n  let obj = options.plainObjects ? Object.create(null) : {}\n\n  // Iterate over the keys and setup the new object\n\n  const keys = Object.keys(tempObj)\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const newObj = parseKeys(key, tempObj[key], options, typeof str === 'string')\n    obj = utils.merge(obj, newObj, options)\n  }\n\n  if (options.allowSparse === true) {\n    return obj\n  }\n\n  return utils.compact(obj)\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "encode", "isBuffer", "maybeMap", "isArray", "isNonNullishPrimitive", "serializeDate", "normalizeStringifyOptions", "stringify", "import_dist", "import_dist", "isArray"]
}
